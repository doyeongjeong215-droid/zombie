<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zombie Tide - Farming & Tool MVP</title>
    <style>
      :root {
        --bg: #08111f;
        --panel: #10223f;
        --panel2: #19345e;
        --text: #edf2f4;
        --accent: #ffb703;
        --ok: #12d6a4;
        --warn: #ff4d6d;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        background: radial-gradient(circle at top, #15315a 0%, var(--bg) 58%);
        color: var(--text);
        font-family: "Pretendard", "Noto Sans KR", system-ui, sans-serif;
      }
      .wrap {
        max-width: 1180px;
        margin: 0 auto;
        padding: 16px;
        display: grid;
        gap: 14px;
        grid-template-columns: 2fr 1fr;
      }
      .card {
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,.15);
        background: linear-gradient(180deg, var(--panel), var(--panel2));
        padding: 12px;
      }
      h1,h2,p { margin: 0 0 8px; }
      .muted { opacity: .85; font-size: 14px; }
      .game-wrap { position: relative; }
      canvas {
        width: 100%;
        height: auto;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,.2);
        background: #07101f;
        image-rendering: pixelated;
      }
      .hotbar {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        background: rgba(4,8,15,.72);
        border: 1px solid rgba(255,255,255,.25);
        border-radius: 10px;
        padding: 8px;
      }
      .slot {
        min-width: 78px;
        text-align: center;
        font-size: 12px;
        border: 1px solid rgba(255,255,255,.2);
        border-radius: 8px;
        padding: 6px;
        background: rgba(255,255,255,.06);
      }
      .slot.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(255,183,3,.25) inset;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(2,minmax(0,1fr));
        gap: 8px;
        margin-top: 8px;
      }
      .s {
        background: rgba(255,255,255,.08);
        border-radius: 8px;
        padding: 8px;
        font-size: 13px;
      }
      .v { font-size: 19px; font-weight: 700; }
      .log { max-height: 540px; overflow:auto; font-size: 13px; line-height: 1.35; }
      .log p { margin: 0 0 7px; }
      .tag { display:inline-block; font-size:11px; border-radius:999px; padding:2px 6px; margin-right:5px; }
      .act { background: rgba(255,183,3,.28); }
      .ok { background: rgba(18,214,164,.28); }
      .warn { background: rgba(255,77,109,.30); }
      @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; } }
    </style>
  </head>
  <body>
    <div class="wrap">
      <section class="card">
        <h1>ğŸ§­ Zombie Tide (ë†ì‚¬/ë„êµ¬ í™•ì¥ MVP)</h1>
        <p class="muted">ì´ë™: WASD/ë°©í–¥í‚¤ Â· ì‚¬ìš©: Space Â· ë‹¬ë¦¬ê¸°: Shift Â· ë„êµ¬ ì„ íƒ: 1~5</p>
        <div class="game-wrap">
          <canvas id="game" width="832" height="544"></canvas>
          <div class="hotbar" id="hotbar"></div>
        </div>
        <div class="stats" id="stats"></div>
      </section>
      <section class="card">
        <h2>ğŸ“œ ë¡œê·¸</h2>
        <p class="muted">ê³µí„°ì— ë‚˜ë¬´/ê´‘ì„ì„ ë°°ì¹˜í–ˆìŠµë‹ˆë‹¤. ë„êµ¬ë¡œ ë•…íŒŒê¸°Â·ë²Œëª©Â·ì±„ê´‘ í›„ ì‘ë¬¼ ì‹¬ê¸°ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
        <div class="log" id="log"></div>
      </section>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const logEl = document.getElementById("log");
      const statsEl = document.getElementById("stats");
      const hotbarEl = document.getElementById("hotbar");
      const W = canvas.width, H = canvas.height;
      const TILE = 32;
      const keys = new Set();

      const tools = [
        { key: "1", icon: "ğŸª“", name: "ë„ë¼" },
        { key: "2", icon: "â›ï¸", name: "ê³¡ê´­ì´" },
        { key: "3", icon: "ğŸ§¹", name: "ê´­ì´" },
        { key: "4", icon: "ğŸŒ±", name: "ì”¨ì•—" },
        { key: "5", icon: "ğŸ—¡ï¸", name: "ë¬´ê¸°" },
      ];

      const state = {
        day: 1,
        dayTime: 0,
        dayLength: 120,
        food: 60,
        wood: 20,
        stone: 10,
        ore: 0,
        seeds: 18,
        stamina: 100,
        hp: 100,
        memory: 50,
        fear: 18,
        infection: 0,
        farm: 100,
        shipFound: false,
        shipProgress: 0,
        atSea: false,
        seaTimer: 0,
        selected: 2,
        interactCd: 0,
        hitCd: 0,
        zombies: [],
        spawnTick: 0,
        trees: [],
        ores: [],
        plots: {},
      };

      const player = { x: 416, y: 300, r: 10, speed: 165, dirX: 1, dirY: 0 };

      const zones = {
        field: { x: 64, y: 80, w: 460, h: 400, name: "ê³µí„°" },
        workshop: { x: 566, y: 84, w: 200, h: 120, name: "ì‘ì—…ëŒ€" },
        dock: { x: 566, y: 226, w: 200, h: 110, name: "ì„ ì°©ì¥" },
        camp: { x: 566, y: 360, w: 200, h: 118, name: "ì•¼ì˜ì§€" },
      };

      function log(msg, type="act") {
        const p = document.createElement("p");
        p.innerHTML = `<span class="tag ${type}">${type.toUpperCase()}</span>${msg}`;
        logEl.prepend(p);
      }
      const clamp=(v,a,b)=>Math.max(a,Math.min(v,b));
      const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
      const act = ()=> state.day<=15?1:state.day<=30?2:3;
      const keyOf = (tx,ty) => `${tx},${ty}`;

      function initFieldNodes() {
        for (let i = 0; i < 18; i++) {
          const tx = rnd(2, 14), ty = rnd(3, 13);
          state.trees.push({ tx, ty, hp: 3 });
        }
        for (let i = 0; i < 9; i++) {
          const tx = rnd(3, 14), ty = rnd(3, 13);
          state.ores.push({ tx, ty, hp: 4 });
        }
      }

      function renderHotbar() {
        hotbarEl.innerHTML = tools.map((tool, i) => `
          <div class="slot ${state.selected===i?"active":""}">
            <div>${tool.key} ${tool.icon}</div>
            <div>${tool.name}</div>
          </div>
        `).join("");
      }

      function tileFromPos(x, y) {
        return { tx: Math.floor(x / TILE), ty: Math.floor(y / TILE) };
      }

      function frontTile() {
        const px = player.x + player.dirX * TILE * 0.9;
        const py = player.y + player.dirY * TILE * 0.9;
        return tileFromPos(px, py);
      }

      function tileCenter(tx, ty) {
        return { x: tx * TILE + TILE / 2, y: ty * TILE + TILE / 2 };
      }

      function inRect(x, y, r) { return x > r.x && x < r.x + r.w && y > r.y && y < r.y + r.h; }

      function findTree(tx, ty) { return state.trees.find(t => t.tx === tx && t.ty === ty); }
      function findOre(tx, ty) { return state.ores.find(o => o.tx === tx && o.ty === ty); }

      function useTool() {
        if (state.interactCd > 0) return;
        state.interactCd = 0.18;

        const { tx, ty } = frontTile();
        const k = keyOf(tx, ty);
        const plot = state.plots[k] || { tilled: false, crop: null };

        // ì‘ì—…ëŒ€ ìƒí˜¸ì‘ìš©
        if (inRect(player.x, player.y, zones.workshop)) {
          if (state.wood >= 8 && state.ore >= 2 && state.shipFound) {
            state.wood -= 8; state.ore -= 2;
            state.shipProgress = clamp(state.shipProgress + rnd(8, 15), 0, 100);
            log(`ì‘ì—…ëŒ€ì—ì„œ ì„ ì²´ ìˆ˜ë¦¬ ì§„í–‰: ${state.shipProgress}%`, "ok");
          } else if (!state.shipFound) {
            log("ë‚œíŒŒì„ ì„ ë¨¼ì € ë°œê²¬í•´ì•¼ í•©ë‹ˆë‹¤.", "warn");
          } else {
            log("ì„ ì²´ ìˆ˜ë¦¬ ì¬ë£Œ ë¶€ì¡± (ëª©ì¬8+ê´‘ì„2 í•„ìš”)", "warn");
          }
          return;
        }

        if (inRect(player.x, player.y, zones.camp)) {
          state.stamina = clamp(state.stamina + 22, 0, 100);
          state.food = Math.max(0, state.food - 4);
          state.memory = clamp(state.memory + 6, 0, 100);
          log("ì•¼ì˜ì§€ì—ì„œ íœ´ì‹: ê¸°ë ¥/ê¸°ì–µë ¥ íšŒë³µ", "act");
          return;
        }

        if (inRect(player.x, player.y, zones.dock)) {
          if (!state.shipFound || state.shipProgress < 100) {
            log("ì„ ì°©ì¥: ë°°ë¥¼ ì™„ì „íˆ ìˆ˜ë¦¬í•´ì•¼ ì¶œí•­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.", "warn");
          } else if (state.atSea) {
            log("ì´ë¯¸ ì›ì • ì¤‘ì…ë‹ˆë‹¤.", "warn");
          } else {
            state.atSea = true;
            state.seaTimer = 30;
            state.food = Math.max(0, state.food - 10);
            state.stamina = clamp(state.stamina - 10, 0, 100);
            log("â›µ ì™¸í•´ ì›ì • ì¶œë°œ! ê¸°ì§€ëŠ” ìë™ ë°©ì–´ ìƒíƒœ", "act");
          }
          return;
        }

        const current = tools[state.selected];
        if (!inRect(player.x, player.y, zones.field)) {
          if (current.name !== "ë¬´ê¸°") {
            log("ë„êµ¬ëŠ” ê³µí„°ì—ì„œ ì‚¬ìš©í•˜ì„¸ìš”.", "warn");
            return;
          }
        }

        if (current.name === "ê´­ì´") {
          if (findTree(tx, ty) || findOre(tx, ty)) {
            log("í•´ë‹¹ ì¹¸ì— ì¥ì• ë¬¼ì´ ìˆì–´ ë•…ì„ íŒ” ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", "warn");
            return;
          }
          if (!plot.tilled) {
            plot.tilled = true;
            state.plots[k] = plot;
            state.stamina = clamp(state.stamina - 4, 0, 100);
            log(`ë•…ì„ ê°ˆì•˜ìŠµë‹ˆë‹¤. (${tx},${ty})`, "ok");
          }
          return;
        }

        if (current.name === "ì”¨ì•—") {
          if (state.seeds <= 0) { log("ì”¨ì•—ì´ ì—†ìŠµë‹ˆë‹¤.", "warn"); return; }
          if (plot.tilled && !plot.crop) {
            plot.crop = { stage: 0, age: 0 };
            state.seeds -= 1;
            state.plots[k] = plot;
            state.stamina = clamp(state.stamina - 2, 0, 100);
            log("ì”¨ì•—ì„ ì‹¬ì—ˆìŠµë‹ˆë‹¤.", "ok");
          } else {
            log("ê°ˆì•„ë‘” ë¹ˆ ë•…ì—ë§Œ ì‹¬ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.", "warn");
          }
          return;
        }

        if (current.name === "ë„ë¼") {
          const tree = findTree(tx, ty);
          if (!tree) { log("ì• ì¹¸ì— ë²¨ ìˆ˜ ìˆëŠ” ë‚˜ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤.", "warn"); return; }
          tree.hp -= 1;
          state.stamina = clamp(state.stamina - 3, 0, 100);
          if (tree.hp <= 0) {
            state.trees = state.trees.filter(t => t !== tree);
            state.wood += rnd(3, 6);
            log("ë²Œëª© ì™„ë£Œ! ëª©ì¬ë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤.", "ok");
          } else {
            log("ë‚˜ë¬´ë¥¼ ì°ì—ˆìŠµë‹ˆë‹¤.", "act");
          }
          return;
        }

        if (current.name === "ê³¡ê´­ì´") {
          const ore = findOre(tx, ty);
          if (!ore) { log("ì• ì¹¸ì— ìº˜ ìˆ˜ ìˆëŠ” ê´‘ì„ì´ ì—†ìŠµë‹ˆë‹¤.", "warn"); return; }
          ore.hp -= 1;
          state.stamina = clamp(state.stamina - 4, 0, 100);
          if (ore.hp <= 0) {
            state.ores = state.ores.filter(o => o !== ore);
            state.stone += rnd(2, 4);
            state.ore += rnd(1, 2);
            log("ì±„ê´‘ ì„±ê³µ! ëŒ/ê´‘ì„ íšë“", "ok");
          } else {
            log("ê´‘ì„ì„ ì±„êµ´ ì¤‘ì…ë‹ˆë‹¤.", "act");
          }
          return;
        }

        // ë¬´ê¸°
        let target = null;
        for (const z of state.zombies) {
          const d = Math.hypot(player.x - z.x, player.y - z.y);
          if (d < 56) { target = z; break; }
        }
        if (!target) {
          log("ê·¼ì²˜ì— ê³µê²©í•  ì¢€ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤.", "warn");
          return;
        }
        target.hp -= 45;
        state.stamina = clamp(state.stamina - 3, 0, 100);
        log("ì¢€ë¹„ë¥¼ ê³µê²©í–ˆìŠµë‹ˆë‹¤!", "ok");
      }

      function spawnZombie() {
        const edge = rnd(0,3);
        let x=0,y=0;
        if (edge===0){x=rnd(0,W);y=-10;}
        if (edge===1){x=W+10;y=rnd(0,H);}
        if (edge===2){x=rnd(0,W);y=H+10;}
        if (edge===3){x=-10;y=rnd(0,H);}
        state.zombies.push({ x, y, hp: 100, speed: rnd(40, 60) });
      }

      function dailyTick() {
        state.day += 1;
        state.food -= 8;
        state.stamina = clamp(state.stamina - 3, 0, 100);
        state.memory = clamp(state.memory - (state.atSea ? 6 : 2), 0, 100);
        if (state.food <= 0) {
          state.food = 0;
          state.infection = clamp(state.infection + 6, 0, 100);
          state.fear = clamp(state.fear + 8, 0, 100);
          log("ì‹ëŸ‰ ê³ ê°ˆ! ê°ì—¼/ê³µí¬ ìƒìŠ¹", "warn");
        }
        if (state.memory < 20) state.fear = clamp(state.fear + 4, 0, 100);

        // ì‘ë¬¼ ì„±ì¥
        for (const key of Object.keys(state.plots)) {
          const p = state.plots[key];
          if (p.crop) {
            p.crop.age += 1;
            if (p.crop.age >= 2 && p.crop.stage < 3) {
              p.crop.age = 0;
              p.crop.stage += 1;
            }
            if (p.crop.stage >= 3) {
              state.food += rnd(3, 6);
              p.crop = null;
              p.tilled = true;
              log("ì‘ë¬¼ì´ ìë¼ ìˆ˜í™•ë˜ì—ˆìŠµë‹ˆë‹¤! ì‹ëŸ‰ +", "ok");
            }
          }
        }

        if (!state.shipFound && state.day >= 6) {
          state.shipFound = true;
          log("í•´ì•ˆì—ì„œ ë‚œíŒŒì„ ì„ ì°¾ì•„ëƒˆìŠµë‹ˆë‹¤. ìˆ˜ë¦¬ë¥¼ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.", "act");
        }
      }

      function update(dt) {
        state.dayTime += dt;
        if (state.dayTime >= state.dayLength) {
          state.dayTime = 0;
          dailyTick();
        }

        if (state.interactCd > 0) state.interactCd -= dt;
        if (state.hitCd > 0) state.hitCd -= dt;

        const run = keys.has("Shift") && state.stamina > 0;
        const speed = player.speed * (run ? 1.45 : 1);
        if (run) state.stamina = clamp(state.stamina - 12 * dt, 0, 100);

        let dx = 0, dy = 0;
        if (keys.has("ArrowUp") || keys.has("w")) dy -= 1;
        if (keys.has("ArrowDown") || keys.has("s")) dy += 1;
        if (keys.has("ArrowLeft") || keys.has("a")) dx -= 1;
        if (keys.has("ArrowRight") || keys.has("d")) dx += 1;

        if (dx || dy) {
          const l = Math.hypot(dx, dy);
          dx /= l; dy /= l;
          player.x = clamp(player.x + dx * speed * dt, 18, W - 18);
          player.y = clamp(player.y + dy * speed * dt, 18, H - 18);
          player.dirX = dx;
          player.dirY = dy;
        }

        const isNight = state.dayTime > state.dayLength * 0.58;
        if (isNight) {
          state.spawnTick += dt;
          const interval = clamp(3.2 - state.day * 0.04, 1.0, 3.2);
          if (state.spawnTick >= interval) {
            state.spawnTick = 0;
            spawnZombie();
          }
        }

        const fieldTarget = { x: zones.field.x + zones.field.w / 2, y: zones.field.y + zones.field.h / 2 };
        for (const z of state.zombies) {
          const distP = Math.hypot(z.x - player.x, z.y - player.y);
          const chaseP = distP < 150;
          const gx = chaseP ? player.x : fieldTarget.x;
          const gy = chaseP ? player.y : fieldTarget.y;
          const vx = gx - z.x, vy = gy - z.y;
          const l = Math.max(1, Math.hypot(vx, vy));
          z.x += (vx / l) * z.speed * dt;
          z.y += (vy / l) * z.speed * dt;

          if (Math.hypot(z.x - player.x, z.y - player.y) < 18 && state.hitCd <= 0) {
            state.hitCd = 0.8;
            state.hp = clamp(state.hp - 7, 0, 100);
            state.fear = clamp(state.fear + 2, 0, 100);
            log("ì¢€ë¹„ì—ê²Œ í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤!", "warn");
          }

          if (inRect(z.x, z.y, zones.field)) {
            state.farm = clamp(state.farm - 5 * dt, 0, 100);
          }
        }
        state.zombies = state.zombies.filter(z => z.hp > 0);

        if (state.atSea) {
          state.seaTimer -= dt;
          if (Math.random() < 0.02 * dt) {
            const dmg = rnd(4, 11);
            state.farm = clamp(state.farm - dmg, 0, 100);
            state.infection = clamp(state.infection + rnd(1, 4), 0, 100);
            log(`ì›ì • ì¤‘ ê¸°ì§€ ìŠµê²©! ë†ì¥ ${dmg}% í”¼í•´`, "warn");
          }
          if (Math.random() < 0.015 * dt) {
            const loot = rnd(2, 5);
            state.ore += loot;
            state.memory = clamp(state.memory + 3, 0, 100);
            log(`ì™¸í•´ íƒì‚¬ ì„±ê³¼: ê´‘ì„ +${loot}`, "ok");
          }
          if (state.seaTimer <= 0) {
            state.atSea = false;
            log("ì›ì • ê·€í™˜ ì™„ë£Œ", "act");
          }
        }

        if (state.hp <= 0 || state.farm <= 0 || state.infection >= 100) {
          log("ì½œë¡œë‹ˆ ë¶•ê´´. ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ì¬ì‹œì‘í•˜ì„¸ìš”.", "warn");
          cancelAnimationFrame(loopId);
        }
      }

      function drawZone(r, color) {
        ctx.fillStyle = color;
        ctx.fillRect(r.x, r.y, r.w, r.h);
      }

      function drawFieldGrid() {
        for (let y = 0; y < H / TILE; y++) {
          for (let x = 0; x < W / TILE; x++) {
            const cx = x * TILE, cy = y * TILE;
            if (inRect(cx + 1, cy + 1, zones.field)) {
              ctx.fillStyle = "#2b4b2e";
              ctx.fillRect(cx, cy, TILE - 1, TILE - 1);
              const p = state.plots[keyOf(x, y)];
              if (p?.tilled) {
                ctx.fillStyle = "#5d3f23";
                ctx.fillRect(cx + 2, cy + 2, TILE - 5, TILE - 5);
              }
              if (p?.crop) {
                const colors = ["#6dbf45", "#8ecf62", "#c2e56f", "#f3ff9f"];
                ctx.fillStyle = colors[p.crop.stage] || colors[3];
                ctx.beginPath();
                ctx.arc(cx + 16, cy + 16, 6 + p.crop.stage, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }
        }
      }

      function drawNodes() {
        for (const t of state.trees) {
          const c = tileCenter(t.tx, t.ty);
          ctx.fillStyle = "#6c9a36";
          ctx.beginPath();
          ctx.arc(c.x, c.y, 11, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#523417";
          ctx.fillRect(c.x - 3, c.y + 7, 6, 9);
        }
        for (const o of state.ores) {
          const c = tileCenter(o.tx, o.ty);
          ctx.fillStyle = "#8a93a8";
          ctx.beginPath();
          ctx.moveTo(c.x, c.y - 11);
          ctx.lineTo(c.x + 11, c.y);
          ctx.lineTo(c.x + 4, c.y + 11);
          ctx.lineTo(c.x - 9, c.y + 8);
          ctx.lineTo(c.x - 11, c.y - 3);
          ctx.closePath();
          ctx.fill();
        }
      }

      function draw() {
        const isNight = state.dayTime > state.dayLength * 0.58;
        ctx.fillStyle = isNight ? "#06101d" : "#0c1a2c";
        ctx.fillRect(0, 0, W, H);

        drawZone(zones.workshop, "#4c5e79");
        drawZone(zones.dock, "#31506e");
        drawZone(zones.camp, "#6f5940");
        drawFieldGrid();
        drawNodes();

        ctx.fillStyle = "rgba(255,255,255,.9)";
        ctx.font = "12px sans-serif";
        for (const z of Object.values(zones)) ctx.fillText(z.name, z.x + 8, z.y + 18);

        for (const z of state.zombies) {
          ctx.beginPath();
          ctx.fillStyle = "#b5179e";
          ctx.arc(z.x, z.y, 10, 0, Math.PI * 2);
          ctx.fill();
        }

        const front = frontTile();
        ctx.strokeStyle = "rgba(255,183,3,.95)";
        ctx.lineWidth = 2;
        ctx.strokeRect(front.tx * TILE + 2, front.ty * TILE + 2, TILE - 4, TILE - 4);

        ctx.beginPath();
        ctx.fillStyle = "#ffb703";
        ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(player.x + player.dirX * 16, player.y + player.dirY * 16);
        ctx.stroke();

        if (isNight) {
          ctx.fillStyle = "rgba(0,0,0,.30)";
          ctx.fillRect(0, 0, W, H);
        }
      }

      function renderStats() {
        const isNight = state.dayTime > state.dayLength * 0.58;
        const rows = [
          ["Day / Act", `${state.day} / ${act()}`],
          ["ì‹œê°„", isNight ? "ğŸŒ™ ì•¼ê°„" : "â˜€ï¸ ì£¼ê°„"],
          ["HP", Math.round(state.hp)],
          ["ê¸°ë ¥", Math.round(state.stamina)],
          ["ì‹ëŸ‰", state.food],
          ["ì”¨ì•—", state.seeds],
          ["ëª©ì¬", state.wood],
          ["ëŒ", state.stone],
          ["ê´‘ì„", state.ore],
          ["ë†ì¥", Math.round(state.farm)],
          ["ì„ ë°•", state.shipFound ? `${state.shipProgress}%` : "ë¯¸ë°œê²¬"],
          ["ì›ì •", state.atSea ? `ì§„í–‰ì¤‘ ${Math.ceil(state.seaTimer)}s` : "ëŒ€ê¸°"],
          ["ê°ì—¼ë„", state.infection],
          ["ì¢€ë¹„", state.zombies.length],
        ];
        statsEl.innerHTML = rows.map(([k, v]) => `<div class="s">${k}<div class="v">${v}</div></div>`).join("");
      }

      window.addEventListener("keydown", (e) => {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) e.preventDefault();
        if (e.key === " ") useTool();
        const idx = tools.findIndex(t => t.key === e.key);
        if (idx >= 0) {
          state.selected = idx;
          renderHotbar();
        }
        keys.add(e.key.length === 1 ? e.key.toLowerCase() : e.key);
      });
      window.addEventListener("keyup", (e) => keys.delete(e.key.length === 1 ? e.key.toLowerCase() : e.key));

      let last = performance.now(), loopId;
      function loop(now) {
        const dt = Math.min(0.033, (now - last) / 1000);
        last = now;
        update(dt);
        draw();
        renderStats();
        loopId = requestAnimationFrame(loop);
      }

      initFieldNodes();
      renderHotbar();
      log("ë†ì‚¬ ê¸°ë°˜ ì‹œì‘: ê³µí„°ì— ê´­ì´(3) â†’ ì”¨ì•—(4) ìˆœì„œë¡œ ì‘ë¬¼ ì¬ë°°", "act");
      log("ë²Œëª©(1)ê³¼ ì±„ê´‘(2)ìœ¼ë¡œ ì„ ë°• ìˆ˜ë¦¬ ìì›ì„ ëª¨ìœ¼ì„¸ìš”.", "act");
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
